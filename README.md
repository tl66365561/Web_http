# 基于http协议实现的一个Web服务器 ——HTTP/1.0版本的在线画图板
功能： 1.实现的是一个HTTP1.0版本的小型服务器，能够实现根据GET和POST的请求方法，响应相应的请求资源 2.能够自主分析是否为CGI并做出相应的处理。 3.针对服务器的性能提升增加了线程池部分，提高了处理高并发的能力 4.针对访问不存在的资源能够返回一个404页面 5.能够实现一个小型的在线画图板和计算器

我将项目主题分为两部分：

一.请求模块

1.根据HTTP请求的格式(首行+请求头+空行+正文)

2.进入处理函数后首先调用RecvOneLine函数，将HTTP请求行处理为一行(因为每一行都是按照\n，\r，\r\n这三种情况，全部转化为\n)，(这里利用了recv的第三个参数MSG_PEEK的窥探下一个字符的功能)

3.解析首行解析出请求方法，url，版本号(这里利用stringstream利用空行分隔开)

4.判断请求方法如果不是POST/GET方法则直接结束，这里调用method

url分别进行解析(先查'?',如果是GET方法且URL中含'?'，则说明该请求是cgi请求。并将路径path和参数param分别保存,如果是POST则URL全部是path) (如果path最末是‘/’则是目录，在后面补上/index.html,path检查方式是调用stat函数，并对路径下文件是目录或可执行文件做分别处理,如果 如果是可执行文件则将更换为cgi模式,顺便将后缀也识别出来,这里是为了标识响应报头中的Content-Type) 同时记录资源大小,为了标识响应报头中的Content-Length.
6.处理请求头，利用请求头的特点是(冒号 + 空格) 将他们分隔开保存在unordered_map中，知道遇到\n也就是空行

7.读取空行和正文，只有POST方法有正文。当是post方法时利用请求头中的content-length: 字段来读取正文

8.这时候就请求结束

二.响应模块

1.非CGI模式

在非CGI模式下就相当于正常的构建响应

构建响应的格式首行(版本号+状态码+状态码解析)+响应头+空行+正文(这里的状态码和状态码解析是利用switch语句构建的）

2.CGI模式

  1.）利用两个匿名管道和fork( )创建的子进程来处理cgi  
  
  2.）构建两条匿名管道,再fork出子进程,两条管道对应父子进程间的数据传输.注意,由于我们要让子进程处理CGI,所以势必会调用exec函数族,一旦替换数据区和代码段,就无法找到操作描述符了(文件描述符表不会被替换,但是你无法知道那个文件描述符是你想要的),所以要先将管道描述符重定向到0,1,还要将参数的长度提前以自定义环境变量的形式进行保存.  
  
  3.）父进程将参数param全部传入管道1,并等待子进程处理完毕,  
  
  4.）子进程接收到参数后,然后调用exec函数执行path路径所指的文件.  
  
  5.） 子进程执行完毕后再通过管道2（cout标记的管道2）将数据结果反馈给父进程,父进程接收后用来组装成响应正文.  
  
  6.）到这就跟非CGI一样了,直接构建响应并返回.  
  

  在CGI模式中我是实现了一个计算机功能和画图板的功能
